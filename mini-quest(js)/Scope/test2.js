const daehun = (num) => {
    if (num < 10) {
        isRaining = true;
    };
}
daehun(7);
console.log(isRaining);

/*
ReferenceError: isRaining is not defined 가 발생한다.
블록 스코프 내에서만 유효하기 때문에 외부에서는 접근할 수 없다.
이를 해결하기 위해서는 변수 선언을 블록 바깥에서 하는 것이다.
블록 스코프가 아닌, 전역 스코프일 때 어디서든 참조가 가능하다!
클로저로도 해결이 가능하다. 변수를 계속 참조하고 있어서 외부에서 접근하여 값을 변경할 수 있다.
하지만 게속 참조하고 있기 때문에 사용하지 않더라도 가비지컬렉터가 정리하지 못할 수 있다.
이는 메모리 누수로 이어지며, null로 설정해줘여 더이상 참조하지 않아 GC에 의해 정리될 수 있다.
스코프는 함수가 호출될 때가 아니라 어디에 선언되었느냐에 따라서 다르다.
이를 렉시컬 스코프라고 한다.
*/
/*
함수 내부의 변수는 한 번만 선언된다길래 시험해보려고 해봤더니 오류가 떴다.
왜냐하면 블록 내부의 변수를 외부에서 접근할 수 없기 때문이다.
이를 클로저를 사용하여 리턴값을 해주면 게속 변수를 참조하고 있기 때문에 외부에서도 접근 할 수 있다.
즉, 외부 함수는 접근할 수 있으니, 외부함수를 실행하면 저절로 내부 함수가 실행하도록 하면 내부 함수를 사용하는 것과 마찬가지다.
private와 비슷하다는 느낌을 받았다. 직접 사용할 수 없지만 getter setter로 사용하는?
"외부 함수 실행 → 내부 함수 반환 → 내부 함수가 외부 변수 유지" 이 흐름이 클로저의 핵심이다!
const kdaehun = () =>{
    let cnt = 0;
    const increase = () => {
        cnt++;
        console.log(cnt);
    }
}

const go = kdaehun();
go.increase();
go();
go();
*/